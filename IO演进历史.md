# IO演进历史

## UNIX 世界一切皆文件

对计算机而言，Socket FIFO 管道 终端 等一切都是流；

在信息交换过程中，计算机都是对流进行收发操作；即 I/O 操作

### 系统如何知道操作哪个流？

- 由操作系统内核创建文件描述符 (File Descriptor FD) 进行标识

- 一个 FD 即为一个非负整数 对该整数的操作就是对文件(流)的操作。
- 创建一个 Socket 系统调用会返回一个 FD ，对 Socket 的操作就可转化为对描述符的操作 
- 分层 与 抽象 的思想

### I/O 交互流程

- 完整 I/O 流程分为两阶段，经由内核空间，即操作系统处理；经由用户空间 应用程序处理

```markdown
内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中，Linux使用两级保护机制：0级供内核（Kernel）使用，3级供用户程序使用。每个进程都有各自的私有用户空间（0～3G），这个空间对系统中的其他进程是不可见的。最高的1G字节虚拟内核空间则为所有进程及内核共享。
```

- 操作系统和驱动程序运行在内核空间，应用程序运行在用户空间 两者不能简单的使用指针传递数据
- Linux 使用虚拟内存机制，必须通过系统调用请求 Kernel 协助完成 I/O 操作；
- 内核 会为每个I/O 设备维护一个缓冲区，用户的数据可能被换出。当内核空间使用用户空间指针时，对应数据可能不再内存中

### 五种 I/O通信模型

- 阻塞 I/O 模型
  - 

